\section{Reimplementing exercise 1}

As recommended by the compendium, we started exercise 2 by reimplementing exercise $1$ in C. This was for the most part a breeze, since it is possible to do inline arithmetic and Read/Write operations are simpler. For example, the single line of C in listing \ref{C-ex} is equivalent to something like 5 lines of Assembly at the bare minimum, as seen in listing \ref{Assembly-ex}.

\begin{lstlisting}[label=C-ex,caption=BAR]
    *GPIO_PA_DOUT = *GPIO_PC_DIN << 8;
\end{lstlisting}

\begin{lstlisting}[label=Assembly-ex,caption=BAR]
	LDR R4, =GPIO_PA_BASE
	LDR R5, =GPIO_PC_BASE
	LDR R8, [R4, #GPIO_DIN]
	LSL R8, R8, #8
	STR R8, [R5, #GPIO_DOUT]
\end{lstlisting}

However, there was one part that was not easier in C than in Assembly. We were made aware that the WFI instruction was not as readily available on this level as one might have hoped. In order to make the development board sleep, we would still have to call that instruction directly as an Assembly instruction.

To achieve this we had a couple options. One was using inline assembly to call the single instruction. The other option, which we used, was to create an Assembly file containing only a subroutine consisting only of the single instruction, called simply wfi. Then a function prototype \texttt{void wfi(void)} was declared in the C code, and the Makefile edited to include compilation of the Assembly file and the linking together of this new compiled file with the others. Thus the WFI instruction became available in C as \texttt{wfi()}.

In the end, it turns out this was actually not needed, because we could set up the system to go to sleep automatically upon returning from an interrupt handler. Since an unintended interrupt always occurs at restart, the system goes to deep sleep anyway as soon as this interrupt has been handled.
