\section{Gamepad driver}

Armed with knowledge from the previous exercises and some perception of how a device driver should be structured from reading Linux Device Drivers \cite{ldd} and the compendium, we knew that we wanted our driver and it's interaction with userspace applications to be as interrupt based as possible. Regardless, having never written a driver before, we decided to follow an incremental approach, starting from the basics.

\subsection{Hello World, from the kernel}

The very basics of a kernel module are fairly straight forward. Listing \ref{kernel-module-skeleton} gives a brief overview of the different components that are required in a kernel module.

\begin{lstlisting}[language=C, label=kernel-module-skeleton, caption=Basic kernel module]
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>

// This function is called when the module is inserted into the kernel.
static int __init template_init(void)
{
    printk("Hello World, from the kernel!\n");
    return 0;
}

// This function is called when the module is removed from the kernel.
static void __exit template_cleanup(void)
{
    printk("Goodbye cruel world!\n");
}

module_init(template_init);
module_exit(template_cleanup);

MODULE_DESCRIPTION("Small module, demo only, not very useful.");
MODULE_LICENSE("GPL");
\end{lstlisting}

This in itself is quite selfexplanatory, so we quickly moved on to adding the functions required for having allowing a userspace application interface with the driver.

\subsection{Char driver}

A device driver written as a kernel module can expose itself as a regular file to the rest of the OS, typically in the \texttt{/dev/} directory.
This is called a char driver. For a simple device like the gamepad, a basic example of interfacing would be to open the char device as a file in the application, and reading from it, as one would with any other file. To be able to do this, some boilerplate registration code is necessary in the kernel module. Amongst other things, functions corresponding to the various I/O operations have to be implemented and registered. First of all, we amended the \texttt{gamepad\_init} function to begin implementing a char driver. See listing \ref{fops-gamepad-init}.

\noindent{
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C, label=fops-gamepad-init, caption=init function for char driver]
static int __init gamepad_init(void)
{
    printk(KERN_ALERT "Attempting to load gamepad driver module\n");

    int result;

    /* Dynamically allocate device numbers */
    result = alloc_chrdev_region(device_nr, 0, DEV_NR_COUNT, DRIVER_NAME);

    if (result < 0) {
        printk(KERN_ALERT "Failed to allocate device numbers\n");
        return -1;
    }

    /* Request access to ports */
    if (request_mem_region(GPIO_PA_BASE, GPIO_IFC - GPIO_PA_BASE, DRIVER_NAME) == NULL ) {
        printk(KERN_ALERT "Error requesting GPIO memory region, already in use?\n");
        return -1;
    }
    //ioremap_nocache(GPIO_PA_BASE, GPIO_IFC - GPIO_PA_BASE);

    /* Init GPIO
     * For portability, these writes should be performed with
     * a base address obtained from the ioremap_nocache
     * call above and an offset.
     * What we are doing below is possible since we're not
     * using virtual memory.
     */
    iowrite32(0x33333333, GPIO_PC_MODEL);
    iowrite32(0xFF, GPIO_PC_DOUT);
    iowrite32(0x22222222, GPIO_EXTIPSELL);

    /* add device */
    cdev_init(&gamepad_cdev, &gamepad_fops);
    gamepad_cdev.owner = THIS_MODULE;
    cdev_add(&gamepad_cdev, device_nr, DEV_NR_COUNT);
    cl = class_create(THIS_MODULE, DRIVER_NAME);
    device_create(cl, NULL, device_nr, NULL, DRIVER_NAME);
    return 0;
}
\end{lstlisting}
\end{minipage}
}

In short, we allocate major/minor device numbers, request access to the area in memory the GPIO registers are mapped to, configure the GPIO (much like in the previous exercises) and register our char device with the kernel.
We also added the corresponding deinitialization functionality to the \texttt{gamepad\_exit} function.

At the top of our kernel module we added some function prototypes, a few constants and a file operations struct, as well as the \texttt{cdev} struct corresponding to the one used in the \texttt{init} function. (Listing \ref{module-top})
With all this in place, our char driver appears as \texttt{/dev/gamepad} after \texttt{modprobe}'ing it.

\noindent{
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C, label=module-top, caption=Definitions]
/* Defines */
#define DRIVER_NAME "gamepad"
#define DEV_NR_COUNT 1

/* Function prototypes */
static int __init gamepad_init(void);
static void __exit gamepad_exit(void);
static int gamepad_open(struct inode*, struct file*);
static int gamepad_release(struct inode*, struct file*);
static ssize_t gamepad_read(struct file*, char* __user, size_t,
    loff_t*);
static ssize_t gamepad_write(struct file*, char* __user, size_t,
    loff_t*);
static irqreturn_t gpio_interrupt_handler(int, void*, struct pt_regs*);

/* Static variables */
static dev_t device_nr;
struct cdev gamepad_cdev;
struct class* cl;


/* Module configs */
module_init(gamepad_init);
module_exit(gamepad_exit);
MODULE_DESCRIPTION("Device driver for the gamepad used in TDT4258");
MODULE_LICENSE("GPL");
\end{lstlisting}
\end{minipage}
}

While the basics are in place, our driver would crash under usage at this point, as there is no implementation for the various functions called for different I/O operations. The implementations are outlined in listing \ref{fops-impl}. The only one of these functions that actually does anything interesting is \texttt{gamepad\_read}. The bitstring representing which buttons are pressed is read from the \texttt{GPIO\_PC\_DIN} register and copied to a userspace memory buffer. We chose not to manipulate the bitstring at the driver level, to avoid imposing restrictions on the applications utilizing the driver.

At this point in the implementation, we were able to test the driver in the context it was meant to be used, as an input device. The next step was to make everything work with interrupts and signals.

\noindent{
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C, label=fops-impl, caption=File operations implementation]
static int gamepad_open(struct inode* inode, struct file* filp)
{
    printk(KERN_INFO "Gamepad driver opened\n");
    return 0;
}

/*
 * gamepad_release - function called when closing
 *
 */

static int gamepad_release(struct inode* inode, struct file* filp)
{
    printk(KERN_INFO "Gamepad driver closed\n");
    return 0;
}

/*
 * gamepad_read - reads current button status from GPIO_PC_DIN
 *
 * Copies a decimal number representing the
 * bitstring of buttons pushed to user space buffer.
 */

static ssize_t gamepad_read(struct file* filp, char* __user buff,
        size_t count, loff_t* offp)
{
    /* Read gpio button status and write to buff */
    uint32_t data = ioread32(GPIO_PC_DIN);
    copy_to_user(buff, &data, 1);
    return 1;
}

static ssize_t gamepad_write(struct file* filp, char* __user buff,
        size_t count, loff_t* offp)
{
    printk(KERN_INFO "Writing to buttons doesn't make sense.");
    return 1;
}
\end{lstlisting}
\end{minipage}
}

\subsection{Interrupts and signals}

While the implementation we had at this point worked perfectly well, it forced our user space application to continuously poll the driver for new inputs, effectively blocking the process from doing other things.
For instance, had the I/O between the driver and the application been non-blocking, we could tell the OS to suspend the process until a signal is received, potentially conserving energy.

Working with interrupts in device drivers is well documented in Chapter 10 of Linux Device Drivers \cite[p.~258]{ldd}. How to implement asynchronous notification is also discussed (Chapter 6, LDD \cite{ldd}).
