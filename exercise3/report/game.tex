\newpage
\section{Developing the game}
While developing the gamepad driver, we also began prototyping the game.
Since we had an existing implementation of the game \cite{2048} to reference,
the game mechanics were fairly straightforward to implement.

\subsection{Game board data structure}
Since the board was only to contain values of the form $v = 2^n$, it made sense to store $n$ instead of $v$. Only the case of $n = 0$ is different, as these are not to be displayed as tiles with the value $1$, but rather as empty tiles.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|}
        \hline
        0 & 0 & 0 & 1 & 0 & 1 & 2 & 1 & 0 & 0 & 2 & 4 & 2 & 5 & 8 & 5 \\ \hline
    \end{tabular}
    \caption{An example of how the array \texttt{uint8\_t b[16]} could look.}
    \label{array_b}
\end{table}

\begin{figure}[h!]
    \centering
    \includegraphics[width=5cm]{img/2048.png}
    \caption{How the screen representation of the \texttt{b} array (table \ref{array_b}) would look.}
\end{figure}

\newpage
\subsection{Gamepad input}
Upon starting the game program, the gamepad driver listening is initialized by the function \texttt{init\_gamepad}.

\input{code/init_gamepad}

This sets up the program so that when the driver registers an interrupt, the function \texttt{sigio\_handler()} is called.

\input{code/sigio_handler}
The gamepad driver gives the program a bit string that represents the state of each of the eight buttons.
For this game, we were not interested in any button press combinations, so we used the function we defined in exercise 2 to map the input to a number representing a single button pressed.

\input{code/map_input}

\newpage
\input{graphics}

\newpage
\input{font}
